package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strconv"
	"strings"

	"github.com/jacoelho/banking/registry"
	"github.com/jacoelho/banking/registry/parser"
	"github.com/jacoelho/banking/registry/rule"
)

func validateFunctionName(s string) string {
	return fmt.Sprintf("validate%sIBAN", strings.ReplaceAll(s, " ", ""))
}

func generateFunctionName(s string) string {
	return fmt.Sprintf("generate%sIBAN", strings.ReplaceAll(s, " ", ""))
}

func getBBANFunctionName(s string) string {
	return fmt.Sprintf("get%sBBAN", strings.ReplaceAll(s, " ", ""))
}

// GenerateCodeForCountry generates country-specific validation code.
func GenerateCodeForCountry(w io.Writer, country registry.Country) error {
	result, parseErr := parser.ParseReduced(country.IBAN)
	if parseErr != nil {
		return fmt.Errorf("parsing IBAN structure: %w", parseErr)
	}

	file := &ast.File{
		Name:  ast.NewIdent("iban"),
		Decls: []ast.Decl{},
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`}},
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"github.com/jacoelho/banking/pool"`}},
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"github.com/jacoelho/banking/ascii"`}},
		},
	})

	validateFunc, err := generateValidationFunction(country.Name, validateFunctionName(country.Name), result.Rules, result.Length)
	if err != nil {
		return err
	}
	file.Decls = append(file.Decls, validateFunc)

	generateFunc, err := generateGenerationFunction(country.Name, generateFunctionName(country.Name), result.Rules)
	if err != nil {
		return err
	}
	file.Decls = append(file.Decls, generateFunc)

	bbanFunc, err := generateBBANFunction(country.Name, getBBANFunctionName(country.Name), country, result.Length)
	if err != nil {
		return err
	}
	file.Decls = append(file.Decls, bbanFunc)

	var buf bytes.Buffer

	buf.WriteString("// Code generated by banking/registry; DO NOT EDIT.\n\n")

	fset := token.NewFileSet()
	if err := format.Node(&buf, fset, file); err != nil {
		return err
	}

	_, err = w.Write(buf.Bytes())
	return err
}

// generateValidationFunction creates a validation function
func generateValidationFunction(countryName, funcName string, rules []rule.Rule, length int) (*ast.FuncDecl, error) {
	fn := &ast.FuncDecl{
		Name: ast.NewIdent(funcName),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{{
					Names: []*ast.Ident{ast.NewIdent("iban")},
					Type:  ast.NewIdent("string"),
				}},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{Type: ast.NewIdent("error")}},
			},
		},
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: fmt.Sprintf("// %s validates %s IBAN", funcName, countryName)},
			},
		},
	}

	var stmts []ast.Stmt

	lengthCheck := &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{ast.NewIdent("iban")},
			},
			Op: token.NEQ,
			Y:  &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", length)},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Errorf"),
							},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"unexpected length, want: %d: %%w"`, length)},
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}
	stmts = append(stmts, lengthCheck)

	for _, r := range rules {
		var stmt ast.Stmt
		var err error

		switch ruleItem := r.(type) {
		case *rule.StaticRule:
			stmt, err = generateStaticValidation(ruleItem)
		case *rule.RangeRule:
			stmt, err = generateRangeValidation(ruleItem)
		default:
			return nil, fmt.Errorf("unknown rule type: %T", ruleItem)
		}

		if err != nil {
			return nil, err
		}
		stmts = append(stmts, stmt)
	}

	checksumStmt := &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("c")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun:  ast.NewIdent("checksum"),
					Args: []ast.Expr{ast.NewIdent("iban")},
				},
			},
		},
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("c"),
			Op: token.NEQ,
			Y: &ast.SliceExpr{
				X:    ast.NewIdent("iban"),
				Low:  &ast.BasicLit{Kind: token.INT, Value: "2"},
				High: &ast.BasicLit{Kind: token.INT, Value: "4"},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Errorf"),
							},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: `"incorrect checksum: %w"`},
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}
	stmts = append(stmts, checksumStmt)

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	fn.Body = &ast.BlockStmt{List: stmts}
	return fn, nil
}

// generateStaticValidation creates static rule validation
func generateStaticValidation(r *rule.StaticRule) (ast.Stmt, error) {
	return &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("subject")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.SliceExpr{
					X:    ast.NewIdent("iban"),
					Low:  &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", r.StartPosition)},
					High: &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", r.StartPosition+len(r.Value))},
				},
			},
		},
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("subject"),
			Op: token.NEQ,
			Y:  &ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, r.Value)},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Errorf"),
							},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s, found %%s: %%w"`, r.String())},
								ast.NewIdent("subject"),
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}, nil
}

// generateRangeValidation creates range rule validation
func generateRangeValidation(r *rule.RangeRule) (ast.Stmt, error) {
	var funcName string
	switch r.Format {
	case rule.Digit:
		funcName = "IsDigit"
	case rule.UpperCaseLetters:
		funcName = "IsUpperCase"
	case rule.AlphaNumeric:
		funcName = "IsAlphaNumeric"
	default:
		return nil, fmt.Errorf("unknown range rule format: %v", r.Format)
	}

	return &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("subject")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.SliceExpr{
					X:    ast.NewIdent("iban"),
					Low:  &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", r.StartPosition)},
					High: &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", r.StartPosition+r.Length)},
				},
			},
		},
		Cond: &ast.UnaryExpr{
			Op: token.NOT,
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("ascii"),
					Sel: ast.NewIdent(funcName),
				},
				Args: []ast.Expr{ast.NewIdent("subject")},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Errorf"),
							},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s, found %%s: %%w"`, r.String())},
								ast.NewIdent("subject"),
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}, nil
}

// generateGenerationFunction creates a generation function
func generateGenerationFunction(countryName, funcName string, rules []rule.Rule) (*ast.FuncDecl, error) {
	fn := &ast.FuncDecl{
		Name: ast.NewIdent(funcName),
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("string")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: fmt.Sprintf("// %s generates %s IBAN", funcName, countryName)},
			},
		},
	}

	var stmts []ast.Stmt

	// sb := pool.BytesPool.Get()
	getPoolStmt := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("sb")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X: &ast.SelectorExpr{
						X:   ast.NewIdent("pool"),
						Sel: ast.NewIdent("BytesPool"),
					},
					Sel: ast.NewIdent("Get"),
				},
			},
		},
	}
	stmts = append(stmts, getPoolStmt)

	// defer sb.Free()
	deferStmt := &ast.DeferStmt{
		Call: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("sb"),
				Sel: ast.NewIdent("Free"),
			},
		},
	}
	stmts = append(stmts, deferStmt)

	for _, r := range rules {
		var stmt ast.Stmt
		switch ruleItem := r.(type) {
		case *rule.StaticRule:
			stmt = &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("sb"),
						Sel: ast.NewIdent("WriteString"),
					},
					Args: []ast.Expr{
						&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, ruleItem.Value)},
					},
				},
			}
		case *rule.RangeRule:
			var funcName string
			switch ruleItem.Format {
			case rule.Digit:
				funcName = "Digits"
			case rule.UpperCaseLetters:
				funcName = "UpperCaseLetters"
			case rule.AlphaNumeric:
				funcName = "AlphaNumeric"
			}
			stmt = &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("ascii"),
						Sel: ast.NewIdent(funcName),
					},
					Args: []ast.Expr{
						ast.NewIdent("sb"),
						&ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", ruleItem.Length)},
					},
				},
			}
		}
		stmts = append(stmts, stmt)
	}

	// return ReplaceChecksum(sb.String())
	returnStmt := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.CallExpr{
				Fun: ast.NewIdent("ReplaceChecksum"),
				Args: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("sb"),
							Sel: ast.NewIdent("String"),
						},
					},
				},
			},
		},
	}
	stmts = append(stmts, returnStmt)

	fn.Body = &ast.BlockStmt{List: stmts}
	return fn, nil
}

// generateBBANFunction creates a BBAN extraction function
func generateBBANFunction(countryName, funcName string, country registry.Country, length int) (*ast.FuncDecl, error) {
	fn := &ast.FuncDecl{
		Name: ast.NewIdent(funcName),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{{
					Names: []*ast.Ident{ast.NewIdent("iban")},
					Type:  ast.NewIdent("string"),
				}},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("BBAN")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: fmt.Sprintf("// %s retrieves BBAN structure from %s IBAN", funcName, countryName)},
			},
		},
	}

	var stmts []ast.Stmt

	lengthCheck := &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{ast.NewIdent("iban")},
			},
			Op: token.NEQ,
			Y:  &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", length)},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CompositeLit{Type: ast.NewIdent("BBAN")},
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("fmt"),
								Sel: ast.NewIdent("Errorf"),
							},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"unexpected length, want: %d: %%w"`, length)},
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}
	stmts = append(stmts, lengthCheck)

	bbanFields := []ast.Expr{
		&ast.KeyValueExpr{
			Key: ast.NewIdent("BBAN"),
			Value: &ast.SliceExpr{
				X:    ast.NewIdent("iban"),
				Low:  &ast.BasicLit{Kind: token.INT, Value: "4"},
				High: &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", length)},
			},
		},
		&ast.KeyValueExpr{
			Key:   ast.NewIdent("BankCode"),
			Value: generateBBANField(country.BankCode, "iban"),
		},
		&ast.KeyValueExpr{
			Key:   ast.NewIdent("BranchCode"),
			Value: generateBBANField(country.BranchCode, "iban"),
		},
		&ast.KeyValueExpr{
			Key:   ast.NewIdent("NationalChecksum"),
			Value: generateBBANField(country.NationalChecksum, "iban"),
		},
		&ast.KeyValueExpr{
			Key:   ast.NewIdent("AccountNumber"),
			Value: generateBBANField(country.AccountNumber, "iban"),
		},
	}

	bbanLit := &ast.CompositeLit{
		Type: ast.NewIdent("BBAN"),
		Elts: bbanFields,
	}

	returnStmt := &ast.ReturnStmt{
		Results: []ast.Expr{
			bbanLit,
			ast.NewIdent("nil"),
		},
	}
	stmts = append(stmts, returnStmt)

	fn.Body = &ast.BlockStmt{List: stmts}
	return fn, nil
}

// generateBBANField generates BBAN field extraction as AST expressions
func generateBBANField(field, variableName string) ast.Expr {
	if field == "" {
		return &ast.BasicLit{Kind: token.STRING, Value: `""`}
	}

	fields := strings.Split(field, ":")
	if len(fields) != 2 {
		return &ast.BasicLit{Kind: token.STRING, Value: `""`}
	}

	start, err := strconv.Atoi(fields[0])
	if err != nil {
		return &ast.BasicLit{Kind: token.STRING, Value: `""`}
	}

	end, err := strconv.Atoi(fields[1])
	if err != nil {
		return &ast.BasicLit{Kind: token.STRING, Value: `""`}
	}

	return &ast.SliceExpr{
		X:    ast.NewIdent(variableName),
		Low:  &ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(start + 4)},
		High: &ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(end + 4)},
	}
}

// GenerateValidate generates the main validation dispatch function
func GenerateValidate(w io.Writer, countries []registry.Country) error {
	file := &ast.File{
		Name: ast.NewIdent("iban"),
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`}},
		},
	})

	validateFunc := &ast.FuncDecl{
		Name: ast.NewIdent("Validate"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{{
					Names: []*ast.Ident{ast.NewIdent("iban")},
					Type:  ast.NewIdent("string"),
				}},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{Type: ast.NewIdent("error")}},
			},
		},
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: "// Validate an IBAN"},
			},
		},
	}

	var stmts []ast.Stmt

	// Length check
	lengthCheck := &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{ast.NewIdent("iban")},
			},
			Op: token.LSS,
			Y:  &ast.BasicLit{Kind: token.INT, Value: "2"},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{X: ast.NewIdent("fmt"), Sel: ast.NewIdent("Errorf")},
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: `"unexpected iban length: %w"`},
								ast.NewIdent("ErrValidation"),
							},
						},
					},
				},
			},
		},
	}
	stmts = append(stmts, lengthCheck)

	// code := iban[0:2]
	codeAssign := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("code")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.SliceExpr{
				X:    ast.NewIdent("iban"),
				Low:  &ast.BasicLit{Kind: token.INT, Value: "0"},
				High: &ast.BasicLit{Kind: token.INT, Value: "2"},
			},
		},
	}
	stmts = append(stmts, codeAssign)

	var cases []ast.Stmt
	for _, country := range countries {
		caseClause := &ast.CaseClause{
			List: []ast.Expr{
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, country.Code)},
			},
			Body: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun:  ast.NewIdent(validateFunctionName(country.Name)),
							Args: []ast.Expr{ast.NewIdent("iban")},
						},
					},
				},
			},
		}
		cases = append(cases, caseClause)
	}

	// Default case
	defaultCase := &ast.CaseClause{
		List: nil, // nil means default
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{X: ast.NewIdent("fmt"), Sel: ast.NewIdent("Errorf")},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: `"%s is not supported: %w"`},
							ast.NewIdent("code"),
							ast.NewIdent("ErrValidation"),
						},
					},
				},
			},
		},
	}
	cases = append(cases, defaultCase)

	switchStmt := &ast.SwitchStmt{
		Tag:  ast.NewIdent("code"),
		Body: &ast.BlockStmt{List: cases},
	}
	stmts = append(stmts, switchStmt)

	validateFunc.Body = &ast.BlockStmt{List: stmts}
	file.Decls = append(file.Decls, validateFunc)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by banking/registry; DO NOT EDIT.\n\n")

	fset := token.NewFileSet()
	if err := format.Node(&buf, fset, file); err != nil {
		return err
	}

	_, err := w.Write(buf.Bytes())
	return err
}

// GenerateGenerate generates the main generation dispatch function
func GenerateGenerate(w io.Writer, countries []registry.Country) error {
	file := &ast.File{
		Name: ast.NewIdent("iban"),
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`}},
		},
	})

	cases := make([]ast.Stmt, 0, len(countries)+1)
	for _, country := range countries {
		caseClause := &ast.CaseClause{
			List: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, country.Code)}},
			Body: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun:  ast.NewIdent(generateFunctionName(country.Name)),
							Args: []ast.Expr{},
						},
					},
				},
			},
		}
		cases = append(cases, caseClause)
	}

	defaultCase := &ast.CaseClause{
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.BasicLit{Kind: token.STRING, Value: `""`},
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("fmt"),
							Sel: ast.NewIdent("Errorf"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: `"%s is not supported: %w"`},
							ast.NewIdent("countryCode"),
							ast.NewIdent("ErrValidation"),
						},
					},
				},
			},
		},
	}
	cases = append(cases, defaultCase)

	generateFunc := &ast.FuncDecl{
		Name: ast.NewIdent("Generate"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("countryCode")}, Type: ast.NewIdent("string")},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("string")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent("countryCode")},
						},
						Op: token.NEQ,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "2"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.BasicLit{Kind: token.STRING, Value: `""`},
									&ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("fmt"),
											Sel: ast.NewIdent("Errorf"),
										},
										Args: []ast.Expr{
											&ast.BasicLit{Kind: token.STRING, Value: `"unexpected country code length: %w"`},
											ast.NewIdent("ErrValidation"),
										},
									},
								},
							},
						},
					},
				},
				&ast.SwitchStmt{
					Tag:  ast.NewIdent("countryCode"),
					Body: &ast.BlockStmt{List: cases},
				},
			},
		},
	}

	file.Decls = append(file.Decls, generateFunc)

	fset := token.NewFileSet()
	var buf bytes.Buffer
	buf.WriteString("// Code generated by banking/registry; DO NOT EDIT.\n\n")
	if err := format.Node(&buf, fset, file); err != nil {
		return err
	}
	_, err := w.Write(buf.Bytes())
	return err
}

// GenerateGetBBAN generates the BBAN extraction dispatch function
func GenerateGetBBAN(w io.Writer, countries []registry.Country) error {
	file := &ast.File{
		Name: ast.NewIdent("iban"),
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`}},
		},
	})

	cases := make([]ast.Stmt, 0, len(countries)+1)
	for _, country := range countries {
		caseClause := &ast.CaseClause{
			List: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, country.Code)}},
			Body: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun:  ast.NewIdent(getBBANFunctionName(country.Name)),
							Args: []ast.Expr{ast.NewIdent("iban")},
						},
					},
				},
			},
		}
		cases = append(cases, caseClause)
	}

	defaultCase := &ast.CaseClause{
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CompositeLit{Type: ast.NewIdent("BBAN")},
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("fmt"),
							Sel: ast.NewIdent("Errorf"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: `"%s is not supported: %w"`},
							ast.NewIdent("code"),
							ast.NewIdent("ErrValidation"),
						},
					},
				},
			},
		},
	}
	cases = append(cases, defaultCase)

	getBBANFunc := &ast.FuncDecl{
		Name: ast.NewIdent("GetBBAN"),
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: "// GetBBAN retrieves BBAN from an iban"},
			},
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("iban")}, Type: ast.NewIdent("string")},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("BBAN")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent("iban")},
						},
						Op: token.LSS,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "2"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.CompositeLit{Type: ast.NewIdent("BBAN")},
									&ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("fmt"),
											Sel: ast.NewIdent("Errorf"),
										},
										Args: []ast.Expr{
											&ast.BasicLit{Kind: token.STRING, Value: `"unexpected iban length: %w"`},
											ast.NewIdent("ErrValidation"),
										},
									},
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("code")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.SliceExpr{
							X:    ast.NewIdent("iban"),
							Low:  &ast.BasicLit{Kind: token.INT, Value: "0"},
							High: &ast.BasicLit{Kind: token.INT, Value: "2"},
						},
					},
				},
				&ast.SwitchStmt{
					Tag:  ast.NewIdent("code"),
					Body: &ast.BlockStmt{List: cases},
				},
			},
		},
	}

	file.Decls = append(file.Decls, getBBANFunc)

	fset := token.NewFileSet()
	var buf bytes.Buffer
	buf.WriteString("// Code generated by banking/registry; DO NOT EDIT.\n\n")
	if err := format.Node(&buf, fset, file); err != nil {
		return err
	}
	_, err := w.Write(buf.Bytes())
	return err
}

// GenerateIsSEPA generates SEPA membership checking functions
func GenerateIsSEPA(w io.Writer, countries []registry.Country) error {
	file := &ast.File{
		Name:  ast.NewIdent("iban"),
		Decls: []ast.Decl{},
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`}},
		},
	})

	var countryCases []ast.Stmt
	for _, country := range countries {
		countryCases = append(countryCases, &ast.CaseClause{
			List: []ast.Expr{
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, country.Code)},
			},
			Body: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						ast.NewIdent(fmt.Sprintf("%t", country.IsSEPA)),
						ast.NewIdent("nil"),
					},
				},
			},
		})
	}

	countryCases = append(countryCases, &ast.CaseClause{
		List: nil, // default case
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					ast.NewIdent("false"),
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("fmt"),
							Sel: ast.NewIdent("Errorf"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: `"%s is not supported: %w"`},
							ast.NewIdent("countryCode"),
							ast.NewIdent("ErrValidation"),
						},
					},
				},
			},
		},
	})

	isSEPACountryCodeFunc := &ast.FuncDecl{
		Name: ast.NewIdent("IsSEPACountryCode"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("countryCode")},
						Type:  ast.NewIdent("string"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("bool")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent("countryCode")},
						},
						Op: token.NEQ,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "2"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									ast.NewIdent("false"),
									&ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("fmt"),
											Sel: ast.NewIdent("Errorf"),
										},
										Args: []ast.Expr{
											&ast.BasicLit{Kind: token.STRING, Value: `"unexpected country code length: %w"`},
											ast.NewIdent("ErrValidation"),
										},
									},
								},
							},
						},
					},
				},
				&ast.SwitchStmt{
					Tag:  ast.NewIdent("countryCode"),
					Body: &ast.BlockStmt{List: countryCases},
				},
			},
		},
	}

	isSEPAFunc := &ast.FuncDecl{
		Name: ast.NewIdent("IsSEPA"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("iban")},
						Type:  ast.NewIdent("string"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("bool")},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent("iban")},
						},
						Op: token.LSS,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "2"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									ast.NewIdent("false"),
									&ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("fmt"),
											Sel: ast.NewIdent("Errorf"),
										},
										Args: []ast.Expr{
											&ast.BasicLit{Kind: token.STRING, Value: `"unexpected iban length: %w"`},
											ast.NewIdent("ErrValidation"),
										},
									},
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent("IsSEPACountryCode"),
							Args: []ast.Expr{
								&ast.SliceExpr{
									X:    ast.NewIdent("iban"),
									Low:  &ast.BasicLit{Kind: token.INT, Value: "0"},
									High: &ast.BasicLit{Kind: token.INT, Value: "2"},
								},
							},
						},
					},
				},
			},
		},
	}

	file.Decls = append(file.Decls, isSEPACountryCodeFunc, isSEPAFunc)

	fset := token.NewFileSet()
	var buf bytes.Buffer
	buf.WriteString("// Code generated by banking/registry; DO NOT EDIT.\n\n")
	if err := format.Node(&buf, fset, file); err != nil {
		return err
	}
	_, err := w.Write(buf.Bytes())
	return err
}
