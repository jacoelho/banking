package generator

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"strings"
	"testing"

	"github.com/jacoelho/banking/registry"
)

func TestGeneratedCodeCompilation(t *testing.T) {
	country := registry.Country{
		Code:          "GB",
		Name:          "United Kingdom",
		IBAN:          "GB2!n4!a6!n8!n",
		BBAN:          "4!a6!n8!n",
		BankCode:      "0:4",
		BranchCode:    "4:10",
		AccountNumber: "10:18",
		IsSEPA:        false,
	}

	t.Run("country code generation", func(t *testing.T) {
		var buf bytes.Buffer
		err := GenerateCodeForCountry(&buf, country)
		if err != nil {
			t.Fatalf("GenerateCodeForCountry failed: %v", err)
		}

		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, "test.go", buf.String(), parser.ParseComments)
		if err != nil {
			t.Fatalf("Generated code is not valid Go: %v\n%s", err, buf.String())
		}

		expectedFuncs := []string{
			"validateUnitedKingdomIBAN",
			"generateUnitedKingdomIBAN",
			"getUnitedKingdomBBAN",
		}

		foundFuncs := make(map[string]bool)
		ast.Inspect(file, func(n ast.Node) bool {
			if fn, ok := n.(*ast.FuncDecl); ok {
				foundFuncs[fn.Name.Name] = true
			}
			return true
		})

		for _, expected := range expectedFuncs {
			if !foundFuncs[expected] {
				t.Errorf("Expected function %s not found in generated code", expected)
			}
		}
	})

	t.Run("validate function generation", func(t *testing.T) {
		countries := []registry.Country{country}
		var buf bytes.Buffer
		err := GenerateValidate(&buf, countries)
		if err != nil {
			t.Fatalf("GenerateValidate failed: %v", err)
		}

		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, "validate.go", buf.String(), parser.ParseComments)
		if err != nil {
			t.Fatalf("Generated validate code is not valid Go: %v\n%s", err, buf.String())
		}

		foundValidate := false
		ast.Inspect(file, func(n ast.Node) bool {
			if fn, ok := n.(*ast.FuncDecl); ok && fn.Name.Name == "Validate" {
				foundValidate = true
			}
			return true
		})

		if !foundValidate {
			t.Error("Expected Validate function not found in generated code")
		}
	})

}

func TestGeneratedCodeStructure(t *testing.T) {
	countries := []registry.Country{
		{
			Code:   "AL",
			Name:   "Albania",
			IBAN:   "AL2!n8!n16!c",
			IsSEPA: false,
		},
		{
			Code:   "DE",
			Name:   "Germany",
			IBAN:   "DE2!n8!n10!n",
			IsSEPA: true,
		},
	}

	t.Run("all generator functions produce valid Go", func(t *testing.T) {
		generators := []struct {
			name string
			fn   func(io.Writer, []registry.Country) error
		}{
			{"GenerateValidate", GenerateValidate},
			{"GenerateGenerate", GenerateGenerate},
			{"GenerateGetBBAN", GenerateGetBBAN},
			{"GenerateIsSEPA", GenerateIsSEPA},
		}

		for _, gen := range generators {
			t.Run(gen.name, func(t *testing.T) {
				var buf bytes.Buffer
				err := gen.fn(&buf, countries)
				if err != nil {
					t.Fatalf("%s failed: %v", gen.name, err)
				}

				fset := token.NewFileSet()
				_, err = parser.ParseFile(fset, gen.name+".go", buf.String(), parser.ParseComments)
				if err != nil {
					t.Fatalf("%s generated invalid Go code: %v\n%s", gen.name, err, buf.String())
				}
			})
		}
	})

	t.Run("generated code has correct package", func(t *testing.T) {
		var buf bytes.Buffer
		err := GenerateValidate(&buf, countries)
		if err != nil {
			t.Fatalf("GenerateValidate failed: %v", err)
		}

		generated := buf.String()
		if !strings.Contains(generated, "package iban") {
			t.Error("Generated code does not have correct package declaration")
		}
	})

	t.Run("generated code has header comment", func(t *testing.T) {
		var buf bytes.Buffer
		err := GenerateValidate(&buf, countries)
		if err != nil {
			t.Fatalf("GenerateValidate failed: %v", err)
		}

		generated := buf.String()
		if !strings.Contains(generated, "// Code generated by banking/registry; DO NOT EDIT.") {
			t.Error("Generated code does not have correct header comment")
		}
	})
}

func TestGenerateCodeForCountryEdgeCases(t *testing.T) {
	t.Run("country with spaces in name", func(t *testing.T) {
		country := registry.Country{
			Code:   "US",
			Name:   "United States",
			IBAN:   "US2!n8!n10!n",
			IsSEPA: false,
		}

		var buf bytes.Buffer
		err := GenerateCodeForCountry(&buf, country)
		if err != nil {
			t.Fatalf("GenerateCodeForCountry failed: %v", err)
		}

		generated := buf.String()
		if !strings.Contains(generated, "validateUnitedStatesIBAN") {
			t.Error("Function name does not handle spaces correctly")
		}
	})

	t.Run("empty BBAN fields", func(t *testing.T) {
		country := registry.Country{
			Code:          "XX",
			Name:          "Test",
			IBAN:          "XX2!n8!n",
			BankCode:      "",
			BranchCode:    "",
			AccountNumber: "",
			IsSEPA:        false,
		}

		var buf bytes.Buffer
		err := GenerateCodeForCountry(&buf, country)
		if err != nil {
			t.Fatalf("GenerateCodeForCountry failed: %v", err)
		}

		fset := token.NewFileSet()
		_, err = parser.ParseFile(fset, "test.go", buf.String(), parser.ParseComments)
		if err != nil {
			t.Fatalf("Generated code with empty BBAN fields is not valid Go: %v", err)
		}
	})
}
